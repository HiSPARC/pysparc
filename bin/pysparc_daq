#!/usr/bin/env python

"""HiSPARC data acquisition in Python (PySPARC)"""

import datetime
import logging
import os
import time
import ConfigParser

import pkg_resources
import schedule

from pysparc.hardware import HiSPARCII, HiSPARCIII, TrimbleGPS
from pysparc.ftdi_chip import DeviceNotFoundError
from pysparc.align_adcs import AlignADCs, AlignADCsMasterSlave
from pysparc.events import Stew, ConfigEvent
from pysparc import messages, storage, monitor


SYSTEM_CONFIGFILE = pkg_resources.resource_filename('pysparc', 'config.ini')
CONFIGFILE = os.path.expanduser('~/.pysparc')
ALL_CONFIG_FILES = [SYSTEM_CONFIGFILE, CONFIGFILE]


class DataAcquisition(object):

    def __init__(self):
        self.config = ConfigParser.ConfigParser()

        try:
            self.master = HiSPARCIII()
        except DeviceNotFoundError:
            self.master = HiSPARCII()

        try:
            self.slave = HiSPARCIII(slave=True)
        except DeviceNotFoundError:
            try:
                self.slave = HiSPARCII(slave=True)
            except:
                self.slave = None

        self.gps = TrimbleGPS()
        self.initialize_hardware()

        station_name = self.config.get('DAQ', 'station_name')
        station_number = self.config.getint('DAQ', 'station_number')
        station_password = self.config.get('DAQ', 'station_password')

        self.datastore = storage.NikhefDataStore(station_number,
                                                  station_password)
        self.storage_manager = storage.StorageManager()
        self.storage_manager.add_datastore(self.datastore, 'queue_nikhef')
        self.monitor = monitor.Monitor(station_name)

    def initialize_hardware(self):
        logging.info("Reading config from file")
        self.config.read(ALL_CONFIG_FILES)

        logging.info("Initializing device configuration")
        self.master.config.read_config(self.config)
        if self.slave is not None:
            self.slave.config.read_config(self.config)

        if self.config.getboolean('DAQ', 'force_reset_gps'):
            logging.info("Force reset GPS to factory defaults.")
            self.gps.reset_defaults()
            self.config.set('DAQ', 'force_reset_gps', False)

        if self.config.getboolean('DAQ', 'force_align_adcs'):
            logging.info("Force aligning ADCs.")
            if self.slave is not None:
                align_adcs = AlignADCsMasterSlave(self.master, self.slave)
            else:
                align_adcs = AlignADCs(self.master)
            align_adcs.align()
            self.config.set('DAQ', 'force_align_adcs', False)

        self.write_config()

    def run(self):
        # The first configuration message does not include GPS information.
        # Flush it, and possibly other outdated messages, and request it later.
        self.flush_devices()

        self.stew = Stew()

        logging.info("Taking data.")
        # Give hardware at least 20 seconds to startup
        self.t_msg = time.time() + 20
        t_log = time.time() - .5
        t_status = time.time()
        self.t_config = datetime.date(1970, 1, 1)

        schedule.every(60).seconds.do(self.send_monitor_messages)

        try:
            while True:
                msg = self.master.read_message()
                if msg is not None:
                    self.process_message(msg)
                else:
                    if time.time() - self.t_msg > 20:
                        logging.warning("Hardware is silent, resetting.")
                        self.master.reset_hardware()
                        # Give hardware at least 20 seconds to startup
                        self.t_msg = time.time()

                if time.time() - t_log >= 1:
                    logging.info("Event rate: %.1f Hz", self.stew.event_rate())
                    t_log += 1

                    self.process_and_store_events()

                # Periodically send status messages to the monitor,
                # currently Nagios, and config messages
                if time.time() - t_status >= 60:
                    t_status += 60

                    if self.t_config < datetime.date.today():
                        # update config (set t_config when sent, not here)
                        self.master.send_message(
                            messages.GetControlParameterList())

                schedule.run_pending()

        except KeyboardInterrupt:
            logging.info("Interrupted by user.")

    def process_message(self, msg):
        """Process a hardware message and throw it in the stew."""
        self.t_msg = time.time()
        if isinstance(msg, messages.MeasuredDataMessage):
            self.stew.add_event_message(msg)
        elif isinstance(msg, messages.OneSecondMessage):
            self.stew.add_one_second_message(msg)
            logging.debug("One-second received: %d", msg.timestamp)
        elif isinstance(msg, messages.ControlParameterList):
            config = ConfigEvent(self.master.config)
            self.storage_manager.store_event(config)
            self.t_config = datetime.date.today()
            logging.info("Sent configuration message.")

    def process_and_store_events(self):
        """Process events from the stew and store them in the datastore."""
        self.stew.stir()
        events = self.stew.serve_events()
        self.store_events(events)
        self.stew.drain()

    def send_monitor_messages(self):
        """Send all monitor messages."""
        self.monitor.send_uptime()
        self.monitor.send_cpu_load()
        self.monitor.send_trigger_rate(self.stew.event_rate())

    def flush_devices(self):
        """Flush devices"""
        self.master.flush_device()

    def store_events(self, events):
        for event in events:
            try:
                self.storage_manager.store_event(event)
            except Exception as e:
                logging.error(str(e))
        logging.debug("Stored %d events.", len(events))

    def write_config(self):
        self.master.config.write_config(self.config)
        with open(CONFIGFILE, 'w') as f:
            self.config.write(f)

    def close(self):
        logging.info("Closing down")
        self.master.close()
        self.storage_manager.close()
        self.datastore.close()


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG,
        format='%(asctime)s %(levelname)s:%(name)s:%(message)s')
    # raise urllib3 module log level to WARNING
    requests_log = logging.getLogger("urllib3")
    requests_log.setLevel(logging.WARNING)

    app = DataAcquisition()
    try:
        app.run()
    finally:
        app.close()
