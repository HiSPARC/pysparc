#!/usr/bin/env python

"""HiSPARC data acquisition in Python (PySPARC)"""

import datetime
import logging
import os
import time
import ConfigParser

import pkg_resources
import schedule

from pysparc.hardware import HiSPARCII, HiSPARCIII, TrimbleGPS
from pysparc.ftdi_chip import DeviceNotFoundError
from pysparc.align_adcs import AlignADCs, AlignADCsMasterSlave
from pysparc.events import Stew, ConfigEvent
from pysparc import messages, storage, monitor


SYSTEM_CONFIGFILE = pkg_resources.resource_filename('pysparc', 'config.ini')
CONFIGFILE = os.path.expanduser('~/.pysparc')
ALL_CONFIG_FILES = [SYSTEM_CONFIGFILE, CONFIGFILE]


def run_once(func, *args, **kwargs):
    """Run a job only once."""

    func(*args, **kwargs)
    return schedule.CancelJob


class DataAcquisition(object):

    def __init__(self):
        self.config = ConfigParser.ConfigParser()

        try:
            self.master = HiSPARCIII()
        except DeviceNotFoundError:
            self.master = HiSPARCII()

        try:
            self.slave = HiSPARCIII(slave=True)
        except DeviceNotFoundError:
            try:
                self.slave = HiSPARCII(slave=True)
            except:
                self.slave = None

        self.gps = TrimbleGPS()
        self.initialize_hardware()

        station_name = self.config.get('DAQ', 'station_name')
        station_number = self.config.getint('DAQ', 'station_number')
        station_password = self.config.get('DAQ', 'station_password')

        self.datastore = storage.NikhefDataStore(station_number,
                                                  station_password)
        self.storage_manager = storage.StorageManager()
        self.storage_manager.add_datastore(self.datastore, 'queue_nikhef')
        self.monitor = monitor.Monitor(station_name)

    def initialize_hardware(self):
        logging.info("Reading config from file")
        self.config.read(ALL_CONFIG_FILES)

        logging.info("Initializing device configuration")
        self.master.config.read_config(self.config)
        if self.slave is not None:
            self.slave.config.read_config(self.config)

        if self.config.getboolean('DAQ', 'force_reset_gps'):
            logging.info("Force reset GPS to factory defaults.")
            self.gps.reset_defaults()
            self.config.set('DAQ', 'force_reset_gps', False)

        if self.config.getboolean('DAQ', 'force_align_adcs'):
            logging.info("Force aligning ADCs.")
            if self.slave is not None:
                align_adcs = AlignADCsMasterSlave(self.master, self.slave)
            else:
                align_adcs = AlignADCs(self.master)
            align_adcs.align()
            self.config.set('DAQ', 'force_align_adcs', False)

        self.write_config()

    def run(self):
        # The first configuration message does not include GPS information.
        # Flush it, and possibly other outdated messages, and request it later.
        self.flush_devices()

        self.stew = Stew()

        logging.info("Taking data.")
        # Give hardware at least 20 seconds to startup
        self.t_msg = time.time() + 20
        t_log = time.time() - .5
        t_status = time.time()
        self.t_config = datetime.date(1970, 1, 1)

        schedule.every(1).seconds.do(self.process_and_store_events)
        schedule.every(30).seconds.do(self.request_config_from_device)
        schedule.every().minute.do(self.send_monitor_messages)
        schedule.every().day.at('2:00').do(self.store_config_event)

        # After 1 minute, store the configuration *once*
        schedule.every().minute.do(run_once, self.store_config_event)

        try:
            while True:
                msg = self.master.read_message()
                if msg is not None:
                    self.process_message(msg)
                else:
                    if time.time() - self.t_msg > 20:
                        logging.warning("Hardware is silent, resetting.")
                        self.master.reset_hardware()
                        # Give hardware at least 20 seconds to startup
                        self.t_msg = time.time()

                if time.time() - t_log >= 1:
                    logging.info("Event rate: %.1f Hz", self.stew.event_rate())
                    t_log += 1

                schedule.run_pending()

        except KeyboardInterrupt:
            logging.info("Interrupted by user.")

    def process_message(self, msg):
        """Process a hardware message and throw it in the stew."""
        self.t_msg = time.time()
        if isinstance(msg, messages.MeasuredDataMessage):
            self.stew.add_event_message(msg)
        elif isinstance(msg, messages.OneSecondMessage):
            self.stew.add_one_second_message(msg)
            logging.debug("One-second received: %d", msg.timestamp)
        elif isinstance(msg, messages.ControlParameterList):
            # No need to process this message. This is already done in the
            # hardware class
            pass

    def process_and_store_events(self):
        """Process events from the stew and store them in the datastore."""
        self.stew.stir()
        events = self.stew.serve_events()
        self.store_events(events)
        self.stew.drain()

    def send_monitor_messages(self):
        """Send all monitor messages."""
        self.monitor.send_uptime()
        self.monitor.send_cpu_load()
        self.monitor.send_trigger_rate(self.stew.event_rate())

    def request_config_from_device(self):
        """Request configuration from device.

        This includes gps positions and PMT currents. When the hardware
        responds, the config objects are automatically updated by the hardware
        classes when the message is read, and are available a short time after
        calling this method.

        """
        self.master.send_message(messages.GetControlParameterList())

    def flush_devices(self):
        """Flush devices"""
        self.master.flush_device()

    def store_events(self, events):
        for event in events:
            try:
                self.storage_manager.store_event(event)
            except Exception as e:
                logging.error(str(e))
        logging.debug("Stored %d events.", len(events))

    def store_config_event(self):
        config = ConfigEvent(self.master.config)
        self.storage_manager.store_event(config)
        logging.info("Sent configuration message.")

    def write_config(self):
        self.master.config.write_config(self.config)
        with open(CONFIGFILE, 'w') as f:
            self.config.write(f)

    def close(self):
        logging.info("Closing down")
        self.master.close()
        self.storage_manager.close()
        self.datastore.close()


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO,
        format='%(asctime)s %(levelname)s:%(name)s:%(message)s')
    # raise urllib3 module log level to WARNING
    requests_log = logging.getLogger("urllib3")
    requests_log.setLevel(logging.WARNING)
    # raise schedule module log level to WARNING
    requests_log = logging.getLogger("schedule")
    requests_log.setLevel(logging.WARNING)

    app = DataAcquisition()
    try:
        app.run()
    finally:
        app.close()
